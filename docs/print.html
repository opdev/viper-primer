<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Primer on Viper</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what_is_viper.html"><strong aria-hidden="true">1.1.</strong> What is Viper</a></li><li class="chapter-item expanded "><a href="reading_simple_configs.html"><strong aria-hidden="true">1.2.</strong> Reading Simple Configuration</a></li><li class="chapter-item expanded "><a href="reading_complex_configs.html"><strong aria-hidden="true">1.3.</strong> Reading Complex Configuration</a></li></ol></li><li class="chapter-item expanded "><a href="hands_on.html"><strong aria-hidden="true">2.</strong> Hands on with Viper</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="defining_our_config_file.html"><strong aria-hidden="true">2.1.</strong> Configuring Viper</a></li><li class="chapter-item expanded "><a href="reading_config_values.html"><strong aria-hidden="true">2.2.</strong> Reading Config Values</a></li><li class="chapter-item expanded "><a href="the_viper_singleton.html"><strong aria-hidden="true">2.3.</strong> What's actually happening under the hood</a></li><li class="chapter-item expanded "><a href="init_function.html"><strong aria-hidden="true">2.4.</strong> The init function</a></li><li class="chapter-item expanded "><a href="maps_and_slices.html"><strong aria-hidden="true">2.5.</strong> Maps and Slices</a></li><li class="chapter-item expanded "><a href="env_vars.html"><strong aria-hidden="true">2.6.</strong> Adding Environment Variables</a></li><li class="chapter-item expanded "><a href="env_vars_nested.html"><strong aria-hidden="true">2.7.</strong> Setting Nested Keys via Environment</a></li><li class="chapter-item expanded "><a href="binding_to_structs.html"><strong aria-hidden="true">2.8.</strong> Binding to structs</a></li><li class="chapter-item expanded "><a href="spanning_packages.html"><strong aria-hidden="true">2.9.</strong> Reading configuration across packages</a></li><li class="chapter-item expanded "><a href="setting_defaults.html"><strong aria-hidden="true">2.10.</strong> Setting Defaults</a></li><li class="chapter-item expanded "><a href="setting_values.html"><strong aria-hidden="true">2.11.</strong> Setting Values</a></li><li class="chapter-item expanded "><a href="other_files.html"><strong aria-hidden="true">2.12.</strong> Reading other config files</a></li><li class="chapter-item expanded "><a href="other_formats.html"><strong aria-hidden="true">2.13.</strong> Reading other config formats</a></li><li class="chapter-item expanded "><a href="cobra_integration.html"><strong aria-hidden="true">2.14.</strong> Integrating With Cobra</a></li></ol></li><li class="chapter-item expanded "><a href="final_thoughts.html"><strong aria-hidden="true">3.</strong> Final Thoughts</a></li><li class="chapter-item expanded "><a href="appendix.html"><strong aria-hidden="true">4.</strong> Appendix</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A Primer on Viper</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is a quick reference guide on what the <a href="https://github.com/spf13/viper">spf13/viper</a> package is, and how it can be used to help speed up your development.</p>
<p>As a prerequisite, you'll need to be able to read Golang.</p>
<p>As with previous primers, this does not replace documentation and is aimed at
being just a cheatsheet or quickstart resource!</p>
<p>A note that the developer <a href="https://github.com/spf13">spf13</a> is leaving their role as <a href="https://spf13.com/p/spf13-google/">Product Lead for Go at google</a>. Thanks for everything, Steve!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-viper"><a class="header" href="#what-is-viper">What is Viper</a></h1>
<p>Taken directly from Viper's <a href="https://github.com/spf13/viper#what-is-viper">documentation</a>:</p>
<blockquote>
<p>Viper is a complete configuration solution for Go applications including 12-Factor apps. It is designed to work within an application, and can handle all types of configuration needs and formats.</p>
</blockquote>
<p>Or put simply, <strong>Viper is a library that parses and managings configuration
languages so you don't have to!</strong> Spend less time writing code to manage your
configuration and instead focus on your business logic!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-simple-configuration"><a class="header" href="#reading-simple-configuration">Reading Simple Configuration</a></h1>
<p>Say we've got an application called that has a simple configuration file that looks like this:</p>
<pre><code class="language-yaml">logLevel: debug
magicFeatureEnabled: true
somethingNeatEnabled: false
</code></pre>
<p>That's a pretty simple YAML file that we can easily represent as a Golang struct like so:</p>
<pre><code class="language-go">type Configuration struct {
	LogLevel             string `yaml:&quot;logLevel&quot;`
	MagicFeatureEnabled  bool   `yaml:&quot;magicFeatureEnabled&quot;`
	SomethingNeatEnabled bool   `yaml:&quot;somethingNeatEnabled&quot;`
}
</code></pre>
<p>And these struct tags on each key of the <code>Configuration</code> struct are read by tools like the <a href="https://github.com/go-yaml/yaml.git">go-yaml</a> library to map the data in our YAML file to the struct in our code. Reading this file is as easy as this:</p>
<pre><code class="language-Go">// You can edit this code!
// Click here and start typing.
package main

import (
	&quot;fmt&quot;
	&quot;os&quot;

	&quot;gopkg.in/yaml.v3&quot;
)

func main() {
	d, _ := os.ReadFile(&quot;config.yaml&quot;)
	var cfg Configuration
	yaml.Unmarshal(d, &amp;cfg)

	fmt.Println(&quot;The Log Level is: &quot;, cfg.LogLevel)
	fmt.Println(&quot;We are using the Magic Feature: &quot;, cfg.MagicFeatureEnabled)
	fmt.Println(&quot;We are using Something Neat &quot;, cfg.SomethingNeatEnabled)
}

type Configuration struct {
	LogLevel             string `yaml:&quot;logLevel&quot;`
	MagicFeatureEnabled  bool   `yaml:&quot;magicFeatureEnabled&quot;`
	SomethingNeatEnabled bool   `yaml:&quot;somethingNeatEnabled&quot;`
}
</code></pre>
<p>Running this with our previous configuration file gives us this result:</p>
<pre><code>The Log Level is:  debug
We are using the Magic Feature:  true
We are using Something Neat  false
</code></pre>
<p>So far so good.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-complex-configuration"><a class="header" href="#reading-complex-configuration">Reading Complex Configuration</a></h1>
<p>So we've already got a simple way to read in a file from disk and map it to a
struct in Go, allowing us to make decisions based on the user's configuration.</p>
<p>What if we want the user to be able to pass us JSON instead of YAML? Well that's
not too bad. We just add a few more struct tags like this:</p>
<pre><code class="language-go">type Configuration struct {
	LogLevel             string `yaml:&quot;logLevel&quot; json:&quot;loglevel&quot;`
	MagicFeatureEnabled  bool   `yaml:&quot;magicFeatureEnabled&quot; json:&quot;magicFeatureEnabled&quot;`
	SomethingNeatEnabled bool   `yaml:&quot;somethingNeatEnabled&quot; json:&quot;somethingNeatEnabled&quot;`
}
</code></pre>
<p>And then we can just the <a href="https://pkg.go.dev/encoding/json">encoding/json</a>
library which also has an <code>Unmarshal</code> function. Reading a file from disk has
already been done, so we'd just need to read the file at both a <code>config.json</code> or
<code>config.yaml</code> path and then repeat the process as we did with the YAML
configuration. Easy peasy.</p>
<hr />
<p>These days, environment variables are all the rage. They're easy to change in
continuous integration, test environments, etc. So let's add an environment
variable for each of these... something like:</p>
<pre><code class="language-go">const (
	EnvLogLevel             = &quot;NEATO_LOG_LEVEL&quot;
	EnvMagicFeatureEnabled  = &quot;NEATO_MAGIC_FEATURE_ENABLED&quot;
	EnvSomethingNeatEnabled = &quot;NEATO_SOMETHING_NEAT_ENABLED&quot;
)
</code></pre>
<p>So these are our environment variable keys, and so we need to look for each of
them. In our example <code>neato</code> application, we'll enforce that environment
variables override the configuration file. Establishing and documenting
precedence is important, so that users know exactly how and why a value is being
overridden! </p>
<p>So now our <code>main.go</code> has to handle the precedence, so we'll read the
configuration first, and then we'll read the environment.</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strings&quot;

	&quot;gopkg.in/yaml.v3&quot;
)

const (
	EnvLogLevel             = &quot;NEATO_LOG_LEVEL&quot;
	EnvMagicFeatureEnabled  = &quot;NEATO_MAGIC_FEATURE_ENABLED&quot;
	EnvSomethingNeatEnabled = &quot;NEATO_SOMETHING_NEAT_ENABLED&quot;
)

func main() {
	// read the configuration file from disk and store it in our struct.
	d, _ := os.ReadFile(&quot;config.yaml&quot;)
	var cfg Configuration
	yaml.Unmarshal(d, &amp;cfg)

	// override the configuration with environment variables
	if key := os.Getenv(EnvLogLevel); key != &quot;&quot; {
		cfg.LogLevel = key
	}

	if key := os.Getenv(EnvMagicFeatureEnabled); key != &quot;&quot; {
		envValue := false
		if strings.ToLower(key) == &quot;true&quot; {
			envValue = true
		}

		cfg.MagicFeatureEnabled = envValue
	}

	if key := os.Getenv(EnvSomethingNeatEnabled); key != &quot;&quot; {
		envValue := false
		if strings.ToLower(key) == &quot;true&quot; {
			envValue = true
		}

		cfg.SomethingNeatEnabled = envValue
	}

	// run our business logic
	fmt.Println(&quot;The Log Level is: &quot;, cfg.LogLevel)
	fmt.Println(&quot;We are using the Magic Feature: &quot;, cfg.MagicFeatureEnabled)
	fmt.Println(&quot;We are using Something Neat &quot;, cfg.SomethingNeatEnabled)
}

type Configuration struct {
	LogLevel             string `yaml:&quot;logLevel&quot; json:&quot;loglevel&quot;`
	MagicFeatureEnabled  bool   `yaml:&quot;magicFeatureEnabled&quot; json:&quot;magicFeatureEnabled&quot;`
	SomethingNeatEnabled bool   `yaml:&quot;somethingNeatEnabled&quot; json:&quot;somethingNeatEnabled&quot;`
}
</code></pre>
<p>Without modifying the environment, our output looks like this (values from our
configuration file):</p>
<pre><code>$ go run .
The Log Level is:  debug
We are using the Magic Feature:  true
We are using Something Neat  false
</code></pre>
<p>But if we modify our environment, we see that our environment's values win out
over the configuration file.</p>
<pre><code>$ NEATO_LOG_LEVEL=info go run .
The Log Level is:  info
We are using the Magic Feature:  true
We are using Something Neat  false
</code></pre>
<hr />
<p>So far, things have been pretty simple! But more than half of our main.go file
is focused on handling our configuration... and we haven't even scratched the
surface!</p>
<p>What if we wanted to have more complex configurations, with maps or arrays?</p>
<pre><code class="language-yaml">logging:
	level: debug
	file: /var/log/neato.log
magicFeature:
	enabled: true
	backends:
	- awesome.example.com:8080
	- epic.example.com:8080
somethingNeat: 
	enabled: true
	endpoint: https://neat.example.com/v1/	
</code></pre>
<p>Building out a struct in Go is simple enough, but now each of these keys needs a
corresponding environment variable. And for each environment variable, we'll need to
build out logic that replaces the values read in from our config file with the values 
read in from the environment.</p>
<p>What about default values? If the user didn't provide a value, but we need it to
run our logic, it stands to reason that a sane default should be used. We'll
need to codify that default either by building out a <code>DefaultConfig</code> out of our
<code>Configuration</code> struct, reading a default from disk, or really any other way
that you can architect your solution.</p>
<p>None of these problems are too complex to solve on your own, but the Viper
library aims to help speed up your development by giving you simple hooks that
solve this problem without having to write your own code to do so.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hands-on-with-viper"><a class="header" href="#hands-on-with-viper">Hands on with Viper</a></h1>
<p>Viper is a library, and as such, we just need to import it or <code>go get</code> the
module into our application. For this cheat sheet, we're mostly interested in
the Viper library calls and so we won't really do much business logic other than
just printing out our values. If you want to follow along, create a directory
called <code>configprinter</code> and install Viper into this path.</p>
<pre><code class="language-shell"># create the directory and change into it
mkdir configprinter
cd configprinter

# create an empty main.go
echo package main &gt;&gt; main.go

# initialize the module and install viper
go mod init example.com/configprinter
go get github.com/spf13/viper
go mod tidy
</code></pre>
<p>Then open up <code>main.go</code>.</p>
<p>NOTE: Viper can be very tightly integrated with Cobra. We'll look at that later.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-our-config-file"><a class="header" href="#defining-our-config-file">Defining our Config File</a></h1>
<p>You should have <code>main.go</code> open at this point with just the <code>package main</code>
declaration. To get started, we'll add the Viper import as well as the <code>fmt</code>
package and a basic <code>main</code> funcion that does nothing.</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
)

func main() {
	fmt.Println(&quot;Start&quot;)
	defer fmt.Println(&quot;end&quot;)
}
</code></pre>
<p>The very first thing we'll do is define that we want our users to be able to
define a YAML config file in the running directory. For that, we'll use three
functions from the Cobra library</p>
<pre><code class="language-go">package main

import (
	// ... unchanged ...
)

func main() {
	// ... unchanged ...

	viper.AddConfigPath(&quot;.&quot;)
	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yaml&quot;)
	if err := viper.ReadInConfig(); err != nil {
		// handle this error if you desire
		fmt.Println(&quot;config file not found&quot;)
	}
}
</code></pre>
<p>And at this point, running your code would just print out the start/end messages
and a message indicating that a config file was not found. Simple enough.</p>
<pre><code>$ go run .
Start
config file not found
end
</code></pre>
<p>Create a config file with the name <strong>config.yaml</strong>. Leave it empty, and then run
program again.</p>
<pre><code>touch config.yaml
</code></pre>
<p>The application should stop complaining about not having a configuration file.
Even with no values, the file exists and it has the right extension (.yaml) so
we know that this file is being read by our program.</p>
<pre><code>$ go run .
Start
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-config-values"><a class="header" href="#reading-config-values">Reading Config Values</a></h1>
<p>At this point, we've already defined that the user can put in configuration into
a file <strong>config.yaml</strong> and the application will read it. But what config values
is it reading?</p>
<p>When using viper, access to your configuration values is pretty free-form, and
doesn't require the use of any structs or defined types in your code.</p>
<p>Let's add the <code>logLevel</code> key to our configuration.</p>
<pre><code class="language-shell">echo logLevel: debug &gt;&gt; config.yaml
</code></pre>
<p>And at the very bottom of our <code>main()</code> function, we'll add a print statement
that queries from Viper the value of our <code>logLevel</code> key.</p>
<pre><code class="language-go">package main

// ... unchanged ...

func main() {
    // ... unchanged ...

	fmt.Println(&quot;The log level is set to:&quot;, viper.GetString(&quot;logLevel&quot;))
}
</code></pre>
<p>Running the command shows you the same value for <code>logLevel</code> as is in our configuration.</p>
<pre><code>$ go run .
Start
The log level is set to: debug
end
</code></pre>
<p>And so you really only <em>need</em> to know the <em>type</em> of the value in your
configuration. This is because Go is strongly typed, but YAML has limited types
that can be represented in its markup. There are equivalent <code>Get&lt;Type&gt;</code> functions
for the various types that you can define in Golang.</p>
<p>It's important to note that if you use the <strong>wrong</strong> type getter function, you
get the <strong>empty</strong> value for that type, as <code>viper.Get&lt;Type&gt;</code> functions do not
return errors, or panic. So for example, running <code>viper.GetBool</code> for <code>logLevel</code>
would give us <code>false</code>. Running <code>viper.GetInt</code> would give us zero, etc.</p>
<p>As a practice: add another key to your config <code>enableLogging</code> with value set to
<code>true</code>, and get and print out its value. You can decide what the accompanying message says.</p>
<pre><code>$ go run .
Start
The log level is set to: false
logging is enabled: true
end
</code></pre>
<p>Also, feel free to remove the Start and End statements at this point now that we
have something else printing out for us.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whats-actually-happening"><a class="header" href="#whats-actually-happening">What's actually happening</a></h1>
<p>Before we go on, I want to point out that what's happening here isn't magic.</p>
<p>The Viper library makes a
<a href="https://github.com/spf13/viper/blob/v1.12.0/viper.go#L181">Viper</a> type, which
itself is responsible for implementing all of the logic we've called so far.</p>
<p>That includes:
- setting our configfile name to <code>config</code>
- setting our extension to <code>yaml</code>
- setting the path to <code>.</code> or &quot;my current directory&quot;
- reading in the configuration file at the the above path
- getting values from the configuration file read from that path</p>
<p>But we didn't create any instances of Viper! That's because the viper library
itself provides a &quot;global&quot; or &quot;singleton&quot; instance of the <code>Viper</code> struct (seen
<a href="https://github.com/spf13/viper/blob/v1.12.0/viper.go#L63">here</a>) This is purely
out of convenience to callers, and it allows developers to simply import the
library, tell the library where the configuration file is, and be on their way
writing business logic</p>
<p>If you wanted to create your own instance of a <code>Viper</code> struct, you can
absolutely use the <code>viper.New()</code> function to instantiate one and use it
standalone. For the purpose of this text, however, we'll use the singleton.</p>
<p>Now, back on topic!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-init-function"><a class="header" href="#the-init-function">The init function</a></h1>
<p>So now that we know a little bit about what's happening under the hood, we're
going to change things around just a little bit more before we get back into
Viper's features.</p>
<p>In Go, the <a href="https://go.dev/doc/effective_go#init">init</a> function is a special
function that allows you to establish any kind of state you need to manage for
your code to operate <em>before</em> your <code>main</code> function is executed. The link above
describes in more detail the exact semantics of when the <code>init()</code> function runs,
if you're interested.</p>
<p>We currently have our Viper configuration taking place in our <code>main()</code> function,
but it's more common to have this take place in an <code>init()</code> function, or
something init-adjacent (like another function that is called by a package's
<code>init</code> function). Because Viper tends to represent the global configuration of
an application, it's fairly common to include its configuration in the <code>init</code>
function of your <code>main.go</code>, or as close to your entrpoint as possible. That
ensures that configuration parsing <em>always</em> happens when your entrypoint is
called.</p>
<p>Let's move most of our Viper-related function calls over to the <code>init</code> function
before we go further.</p>
<pre><code class="language-go">package main

import // ... unchanged ... 

func main() {
	if err := viper.ReadInConfig(); err != nil {
		// handle this error if you desire
		fmt.Println(&quot;config file not found&quot;)
	}

	fmt.Println(&quot;The log level is set to:&quot;, viper.GetBool(&quot;logLevel&quot;))
	fmt.Println(&quot;logging is enabled:&quot;, viper.GetBool(&quot;enableLogging&quot;))
}

func init() {
	viper.AddConfigPath(&quot;.&quot;)
	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yaml&quot;)
}
</code></pre>
<p>You might notice that I didn't move the <code>viper.ReadInConfig</code> call into the init
function. You absolutely can do this as well - just make sure to make it the
last thing called. For this example, I've left it in <code>main</code> as it makes things
easier to represent.</p>
<p>Now back to the config hacking!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maps-and-slices"><a class="header" href="#maps-and-slices">Maps and Slices</a></h1>
<p>One of the huge benefits of using a tool like Viper is the ability to use dot
notation to get various config values in your tree. So let's extend our
config.yaml to look like this:</p>
<pre><code class="language-yaml">logLevel: debug
enableLogging: true
metrics:
  listenAddress: 127.0.0.1
  listenPort: 9999
backends:
  - 192.168.10.01:8001
  - 192.168.10.01:8002
  - 192.168.10.01:8003
  - 192.168.10.01:8004
</code></pre>
<p>Now we've got a <code>metrics</code> entry with various keys, and a <code>backends</code> array with
various entries. And we can access them using Viper getter functions.</p>
<p>The <code>metrics</code> end effectively is an &quot;object&quot;, or a &quot;map&quot; in Go terms. Accessing
the listenAddress key can be done using dot notation, similar to what you might
see using tools like <code>jq</code> or <code>yq</code>.</p>
<pre><code class="language-go">func main() {
    // ... unchanged ...

	fmt.Println(&quot;The metrics endpoint is:&quot;,
		fmt.Sprintf(&quot;%s:%s&quot;,
			viper.GetString(&quot;metrics.listenAddress&quot;),
			viper.GetString(&quot;metrics.listenPort&quot;),
		),
	)
}
</code></pre>
<p>An item in the <code>backends</code> key can be accessed the same way:</p>
<pre><code class="language-go">func main() {
    // ... unchanged ...
	fmt.Println(&quot;The first backend is: &quot;, viper.GetString(&quot;backends.0&quot;))
}
</code></pre>
<p>But what if you need the entire slice of <code>backends</code>? There's a getter for that, too:</p>
<pre><code class="language-go">func main() {
    // ... unchanged ...
fmt.Println(&quot;Here are all the backends:&quot;, viper.GetStringSlice(&quot;backends&quot;))
}
</code></pre>
<p>After adding all of these, here's what we see in our output:</p>
<pre><code>The log level is set to: false
logging is enabled: true
The metrics endpoint is: 127.0.0.1:9999
The first backend is:  192.168.10.01:8001
Here are all the backends: [192.168.10.01:8001 192.168.10.01:8002 192.168.10.01:8003 192.168.10.01:8004]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-environment-variables"><a class="header" href="#adding-environment-variables">Adding Environment Variables</a></h1>
<p>One of the more painful things in our introductory example was handling
environment variables, and I promised Viper would make this easier.</p>
<p>Viper actually has a feature called <code>AutomaticEnv</code> which will automatically read
your configuration keys and look for a standardized environment variable string
that matches.</p>
<p>The <a href="https://github.com/spf13/viper#working-with-environment-variables">docs</a> go
into more detail about the semantics of working with environment variables, but
suffice to say that <code>AutomaticEnv</code> will take a key <code>logLevel</code> and look for the
equivalent <code>LOGLEVEL</code> from the environment.</p>
<p>Let's enable <code>AutomaticEnv</code> by adding it to our <code>init()</code> function.</p>
<pre><code class="language-go">func init() {
	viper.AddConfigPath(&quot;.&quot;)
	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yaml&quot;)
	viper.AutomaticEnv()
}
</code></pre>
<p>The run your code while overridding the <code>debug</code> value for <code>LOGLEVEL</code> with <code>info</code>.</p>
<pre><code>$ LOGLEVEL=info go run .
The log level is set to: info
</code></pre>
<p>However, it's possible (and almost likely) for another application to also
expect the <code>LOGLEVEL</code> environment variable, so you can add a prefix to your
environment variables to disambiguate them from others.</p>
<pre><code class="language-go">func init() {
    // ... unchanged ...
	viper.SetEnvPrefix(&quot;cp&quot;)
	viper.AutomaticEnv()
}
</code></pre>
<p>Now our environment variables must have the <code>CP_</code> prefix, e.g. <code>CP_LOGLEVEL</code>.</p>
<pre><code class="language-shell"># nothing happened
$ LOGLEVEL=info go run .
The log level is set to: debug
...

# it changed
$ CP_LOGLEVEL=info go run .
The log level is set to: info
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-nested-keys-via-environment"><a class="header" href="#setting-nested-keys-via-environment">Setting Nested Keys via Environment</a></h1>
<p>Setting a nested key via the environment takes another configuration option.
Accessing nested keys in our configuration cannot be done in most shells using
dot notation, so we just tell Viper to replace any paths that contain a dot with
an underscore.</p>
<pre><code class="language-go">func init() {
    // ... unchanged ...
	viper.SetEnvPrefix(&quot;CP&quot;)
	viper.SetEnvKeyReplacer(strings.NewReplacer(`.`, `_`))
	viper.AutomaticEnv()
}
</code></pre>
<p>Now, the <code>metrics.listenAddress</code> path can be accessed at the environment. Don't forget the prefix!</p>
<pre><code class="language-shell">$ CP_METRICS_LISTENADDRESS=localhost go run .
The log level is set to: debug
logging is enabled: true
The metrics endpoint is: localhost:9999         # this changed!
The first backend is:  192.168.10.01:8001
Here are all the backends: [192.168.10.01:8001 192.168.10.01:8002 192.168.10.01:8003 192.168.10.01:loca8004]
</code></pre>
<p>You can also change the <code>backends</code> array. Just separate your items with spaces:</p>
<pre><code class="language-shell">$ CP_BACKENDS=&quot;10.0.0.1:8001 10.0.0.1:8002&quot; go run .
The log level is set to: debug
logging is enabled: true
The metrics endpoint is: 127.0.0.1:9999
The first backend is:  
Here are all the backends: [10.0.0.1:8001 10.0.0.1:8002]    # two new items!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-to-structs"><a class="header" href="#binding-to-structs">Binding to structs</a></h1>
<p>So while it's not strictly required, you can optionally bind your entire
configuration, or even just pieces of it, to golang struct types. Say we had a
new type <code>MetricsConfig</code> with our metrics-related keys.</p>
<pre><code class="language-go">type MetricsConfig struct {
	ListenAddress string
	ListenPort    string
}
</code></pre>
<p>We can read (or &quot;Unmarshal&quot;) the <code>metrics</code> key from our config directly into this struct:</p>
<pre><code class="language-go">func main() {
    // ... unchanged ...

	var metricsConf MetricsConfig
	viper.UnmarshalKey(&quot;metrics&quot;, &amp;metricsConf)
	fmt.Println(&quot;metricsConf ListenAddress&quot;, metricsConf.ListenAddress)
	fmt.Println(&quot;metricsConf ListenPort&quot;, metricsConf.ListenPort)
}
</code></pre>
<p>Your struct then contains the configuration values for use in whatever functions
you might have.</p>
<pre><code class="language-shell">$ go run .
# ... previous output omitted ...
metricsConf ListenAddress 127.0.0.1
metricsConf ListenPort 9999
</code></pre>
<p>There is also an <code>Unmarshal</code> functionthat allows you to bind the entire
configuration to a struct, should you need it</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-configuration-across-packages"><a class="header" href="#reading-configuration-across-packages">Reading configuration across packages</a></h1>
<p>One of the nicer features of having Viper manage your configuration in its own
singleton is that you can read your configuration across packages, so long as
you've already executed your viper initialization when you work with your other packages.</p>
<p>So as an example, I'll create a new directory (to represent a new package, or
module) called <strong>backends</strong>, and I'll write a small function that enumerates my
<code>backends</code>.</p>
<p>I'm running this from my project's base directory.</p>
<pre><code class="language-shell">mkdir backends
echo package backends &gt;&gt; backends/backends.go
</code></pre>
<p>I have this sample function <code>Enumerate</code>. The logic isn't super important.</p>
<pre><code class="language-go">package backends

import (
	&quot;fmt&quot;

	&quot;github.com/spf13/viper&quot;
)

func Enumerate() {
	fmt.Println(&quot;Hello from the backends package!&quot;)
	backends := viper.GetStringSlice(&quot;backends&quot;)
	for i, backend := range backends {
		fmt.Printf(&quot;%d: %s\n&quot;, i, backend)
	}
}


</code></pre>
<p>What is important is that you notice that I've simply
called <code>viper.GetStringSlice</code> directly. Access to configuration entries is
vastly simplified using tools like Viper. This is also made possible because
we've leveraged our <code>main.go</code>'s <code>init</code> function to configure Viper, and that
doing so causes that configuration to take place well before any of this code is
called.</p>
<p>Add this to your <code>main</code> function and see that it works as expected.</p>
<pre><code class="language-go">func main() {
    // ... unchanged ...

	backends.Enumerate()
}
</code></pre>
<p>And the result is as expected!</p>
<pre><code class="language-shell">$ go run .
# ... unchanged ...
Hello from the backends package!
0: 192.168.10.01:8001
1: 192.168.10.01:8002
2: 192.168.10.01:8003
3: 192.168.10.01:8004
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-defaults"><a class="header" href="#setting-defaults">Setting Defaults</a></h1>
<p>You'll eventually need to set a default value for a configuration item, and
doing so is a single line away.</p>
<p>Let's define an <code>os</code> key to our code. Don't add it to your config.yaml!</p>
<pre><code class="language-go">func main() {
    // ... unchanged ...
	fmt.Println(&quot;The os is&quot;, viper.GetString(&quot;os&quot;))
}

func init() {
    // ... unchanged ...
	viper.SetDefault(&quot;os&quot;, &quot;centos&quot;)
}
</code></pre>
<p>Run the code and see that the default value is returned:</p>
<pre><code class="language-shell">$ go run .
# ... unchanged ...
The os is centos
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-values"><a class="header" href="#setting-values">Setting Values</a></h1>
<p>As we've seen already, Viper (when used with the library's singleton) can easily
be used to access configuration <em>across</em> packages. What if a value needs to be
changed after reading the configuration due to a change in state internally in
your application? </p>
<p>Viper also provides a setter (e.g. <code>viper.Set</code>) to do exactly that. Let's set a key <code>workers</code>. </p>
<pre><code class="language-go">func main() {
    // ... unchanged ...

	fmt.Println(&quot;the worker count is&quot;, viper.GetInt(&quot;workers&quot;))
	fmt.Println(&quot;setting workers to 4&quot;)
	viper.Set(&quot;workers&quot;, 4)
	fmt.Println(&quot;the worker count is:&quot;, viper.GetInt(&quot;workers&quot;))
}
</code></pre>
<p>This produces:</p>
<pre><code class="language-shell">$ go run .
# ... unchanged ...
the worker count is 0
setting workers to 4
the worker count is: 4
</code></pre>
<p>Now the key <code>workers</code> can be accessed from any other package by accessing the
value from Viper.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-other-config-files"><a class="header" href="#reading-other-config-files">Reading other config files</a></h1>
<p>It stands to reason that you may want to allow for multiple locations where a
configuration file might be found. An example might be if your application is
installed via a linux distribution's package manager, and its configuration file
is placed inside the <code>/etc</code> directory.</p>
<p>We've only told Viper to search relative to our current directory (i.e. <code>.</code>). So
let's also add <code>/etc/configprinter</code> and also the local <code>./conf</code> directory.</p>
<pre><code class="language-go">func init() {
	viper.AddConfigPath(&quot;/etc/configprinter/&quot;)
	viper.AddConfigPath(&quot;./conf&quot;)
	viper.AddConfigPath(&quot;.&quot;)
    // ... unchanged ...
}
</code></pre>
<p>Move your configuration to any of these locations and Viper should still find
your config file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-other-config-formats"><a class="header" href="#reading-other-config-formats">Reading other config formats</a></h1>
<p>A given instance of Viper can only read a single configuration <em>format</em> (e.g.
<code>YAML</code>), but Viper can read <em>various</em> configuration formats.</p>
<p>We've told Viper directly that our configuration file would be an the YAML
format by calling this function:</p>
<pre><code class="language-go">	viper.SetConfigType(&quot;yaml&quot;)
</code></pre>
<p>This actually isn't strictly required. What this does is it allows us to call
our configuration file simply <code>config</code> with no extension. It tells Viper exactly
what format to expect.</p>
<p>If you plan on using file extensions for your configuration file, then you can
simply leave this directive out. Then Viper will look for the file <code>config</code>
(which we defined) at any of the configured locations with common file
extensions for its various supported formats.</p>
<p>Here's the same configuration, but as a TOML file:</p>
<pre><code class="language-TOML">backends = ['192.168.10.01:8001', '192.168.10.01:8002', '192.168.10.01:8003', '192.168.10.01:8004']
enablelogging = true
loglevel = 'debug'
os = 'centos'
workers = 4
[metrics]
listenaddress = '127.0.0.1'
listenport = 9999
</code></pre>
<p>Delete the config.yaml file you have and replace it with this contents in a file called config.toml.</p>
<p>Then, remove the <code>viper.SetConfigType</code> call and rerun the code. Everything should still be in place.</p>
<pre><code>$ go run .
The log level is set to: debug
logging is enabled: true
The metrics endpoint is: 127.0.0.1:9999
The first backend is:  192.168.10.01:8001
Here are all the backends: [192.168.10.01:8001 192.168.10.01:8002 192.168.10.01:8003 192.168.10.01:8004]
metricsConf ListenAddress 127.0.0.1
metricsConf ListenPort 9999
Hello from the backends package!
0: 192.168.10.01:8001
1: 192.168.10.01:8002
2: 192.168.10.01:8003
3: 192.168.10.01:8004
The os is centos
the worker count is 4
setting workers to 4
the worker count is: 4
</code></pre>
<p>By the way, need a quick way to convert your config to a different format? Try setting:</p>
<pre><code class="language-go">viper.SetConfigType(&quot;yourformat&quot;)
viper.SafeWriteConfigAs(&quot;path&quot;)
</code></pre>
<p>The list of config types supported by Viper are found <a href="https://github.com/spf13/viper#reading-config-files">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-cobra"><a class="header" href="#integrating-with-cobra">Integrating With Cobra</a></h1>
<p>Note that this section leaves our previous <code>configprinter</code> project behind. The
referenced code is in the <strong>code/snakes</strong> directory of this
<a href="https://github.com/opdev/viper-primer">repository</a>.</p>
<hr />
<p><a href="https://github.com/spf13/cobra">Cobra</a> and viper work really well together.
When building commandline interfaces with cobra, users can specify flags to
indicate behavioral changes in their program, and Viper can receive those values
and store them in configuration.</p>
<p>For this, I've scaffolded a new project using <code>cobra-cli</code>. When calling
<code>cobra-cli</code>, make sure to use the <code>--viper</code> flag to scaffold out the Viper
integrations.</p>
<pre><code>$ cobra-cli init --viper=true
Your Cobra application is ready at
/Users/me/.go/src/github.com/opdev/viper-primer/code/snakes
</code></pre>
<p>As expected, we get some scaffolded code, and most importantly, we get our <code>cmd/root.go</code></p>
<pre><code>$ tree
.
├── LICENSE
├── cmd
│   └── root.go
├── go.mod
├── go.sum
└── main.go
</code></pre>
<p>Typically, the <code>rootCmd</code> is empty and is an organizational command (like calling
<code>cobra-cli</code> with no subcommands), but for this example, we'll make our changes
there so we don't have to scaffold out extra subcommands.</p>
<p>If you've gone through the <a href="https://opdev.github.com/cobra-primer/">Cobra
Primer</a>, you'll notice a few differences
in the <code>cmd/root.go</code> that's scaffolded when Viper support is enabled for your
application.</p>
<p>Notably, you'll see the <code>init()</code> function now calls an <code>initConfig</code> function.
And that <code>initConfig</code> function initializes a basic Viper configuration similar
to what we did in the <strong>configprinter</strong> example project. Here's what we get (a
few comments and blocks have been omitted).</p>
<pre><code class="language-go">package cmd

// imports omitted


var cfgFile string

// ... cobra code omitted

func init() {
	cobra.OnInitialize(initConfig)

	rootCmd.PersistentFlags().StringVar(&amp;cfgFile, &quot;config&quot;, &quot;&quot;, &quot;config file (default is $HOME/.snakes.yaml)&quot;)

	rootCmd.Flags().BoolP(&quot;toggle&quot;, &quot;t&quot;, false, &quot;Help message for toggle&quot;)
}

// initConfig reads in config file and ENV variables if set.
func initConfig() {
	if cfgFile != &quot;&quot; {
		// Use config file from the flag.
		viper.SetConfigFile(cfgFile)
	} else {
		// Find home directory.
		home, err := os.UserHomeDir()
		cobra.CheckErr(err)

		// Search config in home directory with name &quot;.snakes&quot; (without extension).
		viper.AddConfigPath(home)
		viper.SetConfigType(&quot;yaml&quot;)
		viper.SetConfigName(&quot;.snakes&quot;)
	}

	viper.AutomaticEnv() // read in environment variables that match

	// If a config file is found, read it in.
	if err := viper.ReadInConfig(); err == nil {
		fmt.Fprintln(os.Stderr, &quot;Using config file:&quot;, viper.ConfigFileUsed())
	}
}
</code></pre>
<p>Reading the <code>initConfig</code>, code, we'll see that that the user can set a config
file path, which is stored in the variable <code>cfgFile</code>, via a flag. If they do,
that's what's used by Viper. Alternatively, we will check <code>$HOME/.snakes.yaml</code>
for a configuration file.</p>
<p>Finally, <code>viper.AutomaticEnv()</code> is called, meaning that we can override values
using environment variables. Finally, <code>ReadInConfig</code> is called, and so the Viper
configuration file is read.</p>
<p>Uncomment the <code>rootCmd.Run</code> struct key and just fill in some placeholder logic
so that we can execute it without getting help output. I've also removed the
<code>Long</code> and <code>Short</code> descriptions just so that this text looks cleaner:</p>
<pre><code class="language-go">var rootCmd = &amp;cobra.Command{
	Use:   &quot;snakes&quot;,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println(&quot;Run executed&quot;)
	},
}
</code></pre>
<p>At this point, we can run our command and get our demo print statements:</p>
<pre><code>$ go run .
Run executed
</code></pre>
<p><code>cobra-cli</code> scaffolded a <code>--toggle</code> boolean flag for us. Let's add another line
to print the value of that flag.</p>
<pre><code class="language-go">// unchanged
var rootCmd = &amp;cobra.Command{
	Use:   &quot;snakes&quot;,
	Short: &quot;A brief description of your application&quot;,
	Long:  ``,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println(&quot;Run executed&quot;)

		toggleValue, _ := cmd.Flags().GetBool(&quot;toggle&quot;)
		fmt.Println(&quot;Toggle is set to: &quot;, toggleValue)
	},
}
// unchanged
</code></pre>
<p>So if we run this now, we see the toggle value printed (it has a default value
of false). We can set it to true by running something like the following:</p>
<pre><code>$ go run . --toggle
Run executed
The toggle flag is set to:  true
</code></pre>
<p>But right now, this value never makes it to our Viper configuration. Try to access to <code>toggle</code> key using viper, and you'll see that regardless of whether the user runs the command with the <code>--toggle</code> flag, Viper never sees the change.</p>
<pre><code class="language-go">// unchanged
var rootCmd = &amp;cobra.Command{
	Use:   &quot;snakes&quot;,
	Short: &quot;A brief description of your application&quot;,
	Long:  ``,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println(&quot;Run executed&quot;)

		toggleValue, _ := cmd.Flags().GetBool(&quot;toggle&quot;)
		fmt.Println(&quot;The toggle flag is set to: &quot;, toggleValue)
		fmt.Println(&quot;The toggle config in viper is set to:&quot;, viper.GetBool(&quot;toggle&quot;))
	},
}
// unchanged
</code></pre>
<p>And here's what we see when we run this with the <code>--toggle</code> flag:</p>
<pre><code>$ go run . --toggle
Run executed
The toggle flag is set to:  true
The toggle config in viper is set to: false
</code></pre>
<p>Right now, flag values aren't being stored in our Viper configuration. Luckily,
Viper provides a way to bind the flag's value to the configuration.</p>
<p>In our <code>init</code> function, where we define the <code>rootCmd</code>'s flag(s), we can also
bind an equivalent Viper configuration value:</p>
<pre><code class="language-go">func init() {

    // ... unchanged ...

	rootCmd.Flags().BoolP(&quot;toggle&quot;, &quot;t&quot;, false, &quot;Help message for toggle&quot;)
	viper.BindPFlag(&quot;toggle&quot;, rootCmd.Flags().Lookup(&quot;toggle&quot;))
}
</code></pre>
<p>Note that <em>technically</em> we can bind <em>another</em> Viper configuration key to the
flag's key, but mapping the values similarly is common. </p>
<p>Now, we see our Viper configuration contains the value of our flag.</p>
<pre><code class="language-shell">$ go run . --toggle
Run executed
The toggle flag is set to:  true
The toggle config in viper is set to: true

$ go run . 
Run executed
The toggle flag is set to:  false
The toggle config in viper is set to: false
</code></pre>
<h2 id="accessing-configuration-once-youve-integrated-cobra-and-viper"><a class="header" href="#accessing-configuration-once-youve-integrated-cobra-and-viper">Accessing configuration once you've integrated Cobra and Viper</a></h2>
<p>Once you've bound your Viper configuration to Cobra, you can technically access
your user's configuration using either. With that said, it (subjectively) makes
sense to leverage your Viper configuration as your source of truth once your
cobra flags are bound. This is because you can store the values of your flags in
your Viper configuration, but it's not exactly a bi-directional relationship,
and your Viper configuration values don't get stored in your cobra flags.</p>
<p>To that end, if you're going to leverage viper, I would probably aim to use it
as your source of truth.</p>
<h2 id="a-note-on-case-discrepancies-between-viper-and-cobra-flags"><a class="header" href="#a-note-on-case-discrepancies-between-viper-and-cobra-flags">A note on case discrepancies between viper and cobra flags.</a></h2>
<p>Let's add a <code>--log-level</code> string flag, and corresponding Viper binding:</p>
<pre><code class="language-go">func init() {

    // ... unchanged ...
	
	rootCmd.Flags().StringP(&quot;log-level&quot;, &quot;l&quot;, &quot;&quot;, &quot;Help message for log level&quot;)
	viper.BindPFlag(&quot;logLevel&quot;, rootCmd.Flags().Lookup(&quot;log-level&quot;))
}`
</code></pre>
<p>Viper configurations are typically configured using camelCase or snake_case, but
long flags are typically hyphenated. You'll likely want to bind your flag values
to appropriate Viper configuration values in cases where you have hyphenated
long flags by binding them to equivalent values in your preferred Viper-friendly case.</p>
<p>Here, I've decided to use camelCase. If the user provides a configuration file,
the key for log level would need to be <code>logLevel</code>.</p>
<h2 id="a-note-on-precedence"><a class="header" href="#a-note-on-precedence">A note on precedence</a></h2>
<p>It's important to understand the precedence of your configuration, especially
when you integrate with Cobra and mix flags in. I won't document it here, but
it's documented in the Viper documentation:</p>
<p>https://github.com/spf13/viper#why-viper</p>
<h2 id="a-note-on-flag-integration"><a class="header" href="#a-note-on-flag-integration">A note on flag integration</a></h2>
<p>While we demonstrate that Cobra and Viper play nicely together, it's also
possible to integrate with the flag and pflag packages in Golang directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-thoughts"><a class="header" href="#final-thoughts">Final Thoughts</a></h1>
<p>Each library that you use should save you (as a developer) time worrying about a
problem that's already solved, and should free you up to focus on your own
business logic. Hopefuly the Viper library helps you manage your configuration
flexibly so that you can move that much more quickly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
